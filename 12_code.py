
# 原码反码补码
# 1. 二进制的最高位是符号位：0表示正数，1表示负数
# 例子：8位二进制中，最高位(第8位)是符号位
# 01010101 表示正数（最高位是0）
# 11010101 表示负数（最高位是1）

# 2. 正数的原码，反码，补码都一样（三码合一）
# 例子：+5 在8位二进制中
# 原码：00000101
# 反码：00000101 （与原码相同）
# 补码：00000101 （与原码相同）

# 3. 负数的反码=它的原码符号位不变，其他位取反（0变1，1变0）
# 例子：-5 在8位二进制中
# 原码：10000101 （符号位1表示负数，数值部分是5的二进制）
# 反码：11111010 （符号位不变，其他位取反：0000101 -> 1111010）

# 4. 负数的补码=它的反码+1，负数的反码=补码-1
# 例子：-5 的补码计算
# 反码：11111010
# 补码：11111011 （反码+1：11111010 + 1 = 11111011）

# 5. 0的反码，补码都是0
# 例子：0 在8位二进制中
# 原码：00000000
# 反码：00000000
# 补码：00000000

# 6. 在计算机运算的时候，都是以补码的方式来运算的
# 详细说明：
# - CPU的算术逻辑单元(ALU)只能进行加法运算
# - 减法通过加法实现：a - b = a + (-b)
# - 使用补码可以将减法转换为加法，统一运算方式
# - 补码运算的优点：
#   ① 符号位和数值位可以一起参与运算
#   ② 加法和减法使用同一套电路
#   ③ 运算结果自动正确，无需特殊处理
#
# 例子：计算 3 + (-2) = 1
# 3的补码：  00000011
# -2的补码： 11111110 （-2的原码10000010 -> 反码11111101 -> 补码11111110）
# 相加结果： 100000001 （9位，最高位溢出被丢弃）
# 最终结果： 00000001 （即十进制的1，运算正确）

# 例子：计算 2 - 5 = 2 + (-5) = -3
# 2的补码：  00000010
# -5的补码： 11111011 （如上面计算的-5补码）
# 相加结果： 11111101
# 这是补码形式的-3

# 7. 当我们看运算结果的时候，要看他的原码
# 例子：上面的运算结果 11111101 是补码
# 因为最高位是1，说明这是负数
# 要得到原码：补码 -> 反码 -> 原码
# 补码：11111101
# 反码：11111100 （补码-1）
# 原码：10000011 （符号位不变，其他位取反）
# 原码10000011 表示 -3
